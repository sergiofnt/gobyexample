// Тепер, коли ми розглянули
// [запуск сторонніх процесів](spawning-processes), ми знаємо, що ми це робимо
// коли необщідно, щоб запущений процес був доступний нашому Go процесу.
// Інколи, все чого ми бажаємо - це лише повністю замінити поточний Go-процес
// іншим (можливо, навіть - не "Go-процесом"), для цього ми скорастаємось реалізацією
// одного з системних викликів - [exec](http://en.wikipedia.org/wiki/Exec_(operating_system)).

package main

import "syscall"
import "os"
import "os/exec"

func main() {

    // Спробуємо виконати `ls` у нашому прикладі. Go необхідно абсолютний
    // шлях до програми, яку ми хочемо виконати - отож ми скористаємось
    // `exec.LookPath` щоб знайти її (і можливо ми знайдемо її як `/bin/ls`).
    binary, lookErr := exec.LookPath("ls")
    if lookErr != nil {
        panic(lookErr)
    }

    // Параметри передаються в `Exec` у вигляді [`зрізу`](slices)
    // (напротивагу одному рядку). Ми забезпечимо `ls`
    // кількома звичайними (для цієї команди) аргументами.
    args := []string{"-h", "-o"}

    // `Exec` також потребує [змінні оточення](environment-variables)
    // і ми ж надамо йому наше поточне середовище.
    env := os.Environ()

    // А ось - і власне виклик `syscall.Exec`. Якщо виклик успішний,
    // виконання нашого процесу завершиться і буде замінено процесом `/bin/ls -h -o`,
    // а якщо виникне помилка - то ми отримаємо [паніку](panic) з текстом помилки.
    execErr := syscall.Exec(binary, args, env)
    if execErr != nil {
        panic(execErr)
    }
}
