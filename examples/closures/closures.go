// [_Aнонімні функції_](https://uk.wikipedia.org/wiki/Анонімна_функція) (які підтримуються в Go)
// можуть створювати [_замикання_](https://uk.wikipedia.org/wiki/Замикання_(програмування)).
// Це стає в нагоді, за умов коли необхідно декларувати
// функцію без найменування і поводись з нею, як з простою змінною.

package main

import "fmt"

// В нашому прикладі функція `intSeq` створює та повертає іншу функцію,
// оголошуну анонімно в тілі `intSeq`. Функція, що
// повертається, замикається на змінні `i` та формує так зване `замикання`
// або `closure`.
func intSeq() func() int {
    i := 0
    return func() int {
        i++
        return i
    }
}

func main() {

    // Викликаєчи `intSeq` ми присоюємо її результат (нашу анонімну функцію)
    // змінній `nextInt`. Ця функціональна змінна, замикається над
    // власним  значенням змінної `i`, яка оновлюватиметься щоразу `nextInt` буде викликано.
    nextInt := intSeq()

    // Для демонстрації - зробимо кілька викликів `nextInt`.
    fmt.Println(nextInt())
    fmt.Println(nextInt())
    fmt.Println(nextInt())

    // І щоб показати що цей стан є унікальним, стоворимо нове
    // замикання і відразу викличимо його.
    newInts := intSeq()
    fmt.Println(newInts())
}
